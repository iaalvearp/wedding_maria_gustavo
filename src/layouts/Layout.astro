---

---

<!doctype html>
<html lang="es">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<title>Mar√≠a y Gustavo</title>
	</head>
	<body>
		<slot />
	</body>
</html>

<style is:global>
	:root {
		--brown: #694528;
		--orange: #EC6224;
		--gold: #D8A54F;
		--green: #006633;
	}
	html,
	body {
		margin: 0;
		width: 100%;
		height: 100%;
	}
	@font-face {
		font-family: 'Acumin';
		src: url('/fonts/AcuminVariableConcept.woff') format('woff');
	}
	@font-face {
		font-family: 'Geliat';
		src: url('/fonts/GeliatExtralight.otf') format('otf');
	}
	@font-face {
		font-family: 'Minion';
		src: url('/fonts/MinionProItalic.woff') format('woff');
		font-weight: 400;
		font-style: italic;
		font-display: swap;
	}
	@font-face {
		font-family: 'Minion Roman';
		src: url('/fonts/MinionRoman.otf') format('otf');
	}
	@font-face {
		font-family: 'Corporate';
		src: url('/fonts/CorporateSPro-Light.woff') format('woff');
	}
	@font-face {
		font-family: 'Source';
		src: url('/fonts/SourceSansVariable-Roman.otf') format('otf');
	}

	.bright-fade {
		animation: bright 2s ease-in-out;
	}
	@keyframes bright {
		0% {
			opacity: 0;
			filter: blur(20px);
		}
		10% {
			opacity: 1;
			filter: brightness(2) blur(10px);
		}
	}
	.to-return-up {
		opacity: 0;
		transform: translateY(100%);
		transition: all 1s ease-in-out;
	}
	.to-return-down {
		opacity: 0;
		transform: translateY(-100%);
		transition: all 2s ease-in-out;
	}
	.return {
		animation: forwards;
		animation-delay: 1s;
		transform: translateY(0);
		opacity: 1;
	}
	.return-pink {
		animation-delay: 1s;
		animation: return-pink 2s ease;
	}
	@keyframes return-pink {
		0% {
			opacity: 0;
			transform: translateY(50%);
		}
		100% {
			opacity: 0.4;
			transform: translateY(0%);
		}
	}
</style>

<script>
	const returns = document.querySelectorAll('.to-return-down, .to-return-up');
	let observer = new IntersectionObserver((entries) => {
		entries.forEach((entry) => {
			if (entry.isIntersecting) {
				entry.target.classList.add('return');
				observer.unobserve(entry.target);
			} else {
				entry.target.classList.remove('return');
			}
		});
	});
	returns.forEach((returnElement) => {
		observer.observe(returnElement);
	});
</script>
